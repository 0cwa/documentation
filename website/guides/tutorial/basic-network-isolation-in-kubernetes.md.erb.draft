---
$schema: "/.meta/.schemas/guides.json"
title: Basic network isolation in Kubernetes
description: As your number of deployed applications within Kubernetes grows, you may want to isolate them from a network point of view.
author_github: https://github.com/evoxmusic
tags: ["type: tutorial"]
hide_pagination: true
---
import Assumptions from '@site/src/components/Assumptions';


# Basic network isolation in Kubernetes

As your number of deployed applications within Kubernetes grows, you may want to isolate them from a network point of view. By default Kubernetes does not offer any network isolation, all pods of all your namespaces can talk to each other without any isolation and even on network port you have not declared in your yaml files. Yeah that's a bit scary :)

Their is different approach and tools to do the Network Isolation, let's take a look of an easy one the `NetworkPolicy` .

## The Kubernetes Networking plugin

Kubernetes provides a resource called `NetworkPolicy` that allows to create rules to allow/deny some network traffic, a bit like a firewall. By default using this resource doesn't do anything, to make it work you need first to add a Kubernetes Networking plugin that implements it.

Some kubernetes cluster providers propose their own implementation, like [GKS](https://cloud.google.com/kubernetes-engine/docs/how-to/network-policy#using_network_policy_enforcement) or [AKS](https://docs.microsoft.com/en-us/azure/aks/use-network-policies#create-an-aks-cluster-and-enable-network-policy)

Or you can use [Calico](https://docs.projectcalico.org) like [EKS recommanded](https://eksworkshop.com/beginner/120_network-policies/calico/install_calico/)

Before continuing, be sure you have follow one of this Kubernetes Networking Plugin Installation guide.

* GKS: https://cloud.google.com/kubernetes-engine/docs/how-to/network-policy#using_network_policy_enforcement
* AKS: https://docs.microsoft.com/en-us/azure/aks/use-network-policies#create-an-aks-cluster-and-enable-network-policy
* EKS: https://eksworkshop.com/beginner/120_network-policies/calico/install_calico

## The NetworkPolicy rules

When we start doing Network Isolation the logic is the same: block everything and allow only what you need. This is a golden rule for inbound traffic, oubound traffic is generally not so strict if you don't control which resource your applications fetch from Internet.

In example below, we will configure the production to be isolated from all other namespaces, but still allow any pods deployed within production namespace to talk to each other.

First, let's create a namespace:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    role: production
```

*Blocking any traffic going to a namespace is easy*

```yaml
---
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: no-inbound-traffic
  namespace: production
spec:
  policyTypes:
  - Ingress
  podSelector:
    matchLabels: {}
```

As we can see, the rule is simple:

* `policyTypes=Ingress` to select only the incoming traffic
* an empty set in `podSelector/matchLabels`, to apply the rule to all pods within the namespace.
* no `ingress` rule have been defined, so everything is blocked

*Allow any pods within the `production` namespace to talk to each other*

To do so we add another `NetworkPolicy` rule:

```yaml
---
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-same-namespace-traffic
  namespace: production
spec:
  policyTypes:
  - Ingress
  podSelector:
    matchLabels: {}
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          role: production
```

As before this is a `Ingress` rule only that apply to all pods in the `production` namespace.
This time we define `ingress:` to allow all traffic from namespace with the label `role=production`.


*Now open the externally exposed port*

Here I have a web-server application listen on port 8000, we will allow incoming traffic to this port with this additional rules:

```yaml
---
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-port-8000
  namespace: production
spec:
  policyTypes:
  - Ingress
  podSelector:
    matchLabels:
      app=web-server
  ingress:
  - ports:
    - port: 8000
```

Here instead of selecting all pods I pick only those with label `app=web-server` of the `productions` namespace. And then the `ingress:` rule allow anybody to connect to the port 8000 of my web server.


*Ongiong traffic rules*

`NetworkPolicy` can also be used to forbid traffic going somewhere. For example, I may not want my applications be able to read the AWS metadata server information.

To do so, I will add this configuration:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: disable-aws-metadata
  namespace: production
spec:
  policyTypes:
  - Egress
  podSelector:
    matchLabels: {}
  egress:
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
        except:
          - 169.254.169.254/32
```

# Going further

`NetworkPolicy` are useful for simple network traffic filtering, but not enough to have a perfect control to who talk to who. Rules selection is done only with Pod and Namespace Selectors. Once a network port is widely open, a person with bad intentions can still connect directly to the application port (here 8000) and bypass your `Ingress` resources and `Loadbalancer` setup.

In further post, we will see how we can leverage another solution called [Istio](https://istio.io/) to have a perfect control of network flow between applications.

Additional resources:

https://kubernetes.io/docs/concepts/services-networking/network-policies/
https://docs.projectcalico.org/reference/resources/networkpolicy#content-main
https://eksworkshop.com/beginner/120_network-policies/calico/stars_policy_demo/apply_network_policies/
https://cloud.google.com/kubernetes-engine/docs/how-to/network-policy

<Jump to="/guides/tutorial/">Tutorial</Jump>
