---
last_modified_on: "2022-02-02"
$schema: "/.meta/.schemas/guides.json"
title: Deploy Rails with PostgreSQL and Sidekiq
description: How to deploy a Rails application with the PostgreSQL database and Sidekiq workers
author_github: https://github.com/l0ck3
tags: ["type: tutorial", "framework: rails", "language: ruby", "database: postgresql"]
hide_pagination: true
---

import Steps from '@site/src/components/Steps';
import Alert from '@site/src/components/Alert';
import Assumptions from '@site/src/components/Assumptions';

<Assumptions name="guide">

* You have a Qovery cluster ready

</Assumptions>


<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/guides/tutorial/deploy-rails-with-postgresql-and-sidekiq.md.erb
-->

## Goal

In this tutorial we will deploy a typical Rails 6 application, using PostgreSQL as a database and Sidekiq as an ActiveJob backend for background tasks.

## Prepare your Rails application

<Alert type="notice">
  If you don't have a Rails 6 application at hand, you can clone this demo app: https://github.com/Qovery/qovery-rails-full-application-example
</Alert>

<Alert type="warning">
  Qovery doesn't support Procfiles with multiple processes yet. We'll have to use Dockerfiles for both the web application and Sidekiq workers.
  <br />
  Qovery doesn't support overriding Docker command yet, so we'll use two different Dockerfiles.
</Alert>

<Steps headingDepth={3}>

<ol>

<li>

#### Web application Dockerfile

Add a `Dockerfile` file at the root of your application with the following content: 

```Dockerfile
FROM ruby:3.0.2-alpine3.13 AS builder

# Minimal requirements to run a Rails app
RUN apk add --no-cache --update build-base \
  linux-headers \
  git \
  postgresql-dev=~13 \
  # Rails SQL schema format requires `pg_dump(1)` and `psql(1)`
  postgresql=~13 \
  # Install same version of pg_dump
  postgresql-client=~13 \
  nodejs \
  yarn \
  # Needed for nodejs / node-gyp
  python2 \
  tzdata

  
ENV BUNDLER_VERSION 2.2.24
ENV BUNDLE_JOBS 8
ENV BUNDLE_RETRY 5
ENV BUNDLE_WITHOUT development:test
ENV BUNDLE_CACHE_ALL true
ENV RAILS_ENV production
ENV RACK_ENV production
ENV NODE_ENV production
ENV APP_PATH /work

WORKDIR $APP_PATH

# Gems installation
COPY Gemfile Gemfile.lock ./
RUN gem install bundler -v $BUNDLER_VERSION

RUN bundle config --global frozen 1 && \
  bundle install && \
  rm -rf /usr/local/bundle/cache/*.gem && \
  find /usr/local/bundle/gems/ -name "*.c" -delete && \
  find /usr/local/bundle/gems/ -name "*.o" -delete

  

# NPM packages installation
COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile --non-interactive --production

ADD . $APP_PATH

RUN SECRET_KEY_BASE=`bin/rake secret` rails assets:precompile --trace && \
  yarn cache clean && \
  rm -rf node_modules tmp/cache vendor/assets test

  
FROM ruby:3.0.2-alpine3.13

RUN mkdir -p /work
WORKDIR /work

ENV RAILS_ENV production
ENV NODE_ENV production
ENV RAILS_SERVE_STATIC_FILES true

# Some native extensions required by gems such as pg or mysql2.
COPY --from=builder /usr/lib /usr/lib

# Timezone data is required at runtime
COPY --from=builder /usr/share/zoneinfo/ /usr/share/zoneinfo/

# Ruby gems
COPY --from=builder /usr/local/bundle /usr/local/bundle
COPY --from=builder /work /work

COPY docker-entrypoint.sh ./
ENTRYPOINT ["./docker-entrypoint.sh"]

EXPOSE 3000

CMD ["rails", "server", "-p", "3000", "-b", "0.0.0.0"]
```

<Alert type="notice">
  You can tweak the versions if you are using a different version of Ruby, Bundler, PostgreSQL ... 
</Alert>

</li>

<li>

#### Sidekiq Dockerfile

We'll use a similar Dockerfile for our Sidekiq worker.
Create a `Dockerfile.sidekiq` at the root of your repository with the following content: 

```Dockerfile
FROM ruby:3.0.2-alpine3.13 AS builder

LABEL maintener='yirbah@qovery.com'

# Minimal requirements to run a Rails app
RUN apk add --no-cache --update build-base \
  linux-headers \
  git \
  postgresql-dev=~13 \
  # Rails SQL schema format requires `pg_dump(1)` and `psql(1)`
  postgresql=~13 \
  # Install same version of pg_dump
  postgresql-client=~13 \
  nodejs \
  yarn \
  # Needed for nodejs / node-gyp
  python2 \
  tzdata

ENV BUNDLER_VERSION 2.2.24
ENV BUNDLE_JOBS 8
ENV BUNDLE_RETRY 5
ENV BUNDLE_WITHOUT development:test
ENV BUNDLE_CACHE_ALL true
ENV RAILS_ENV production
ENV RACK_ENV production
ENV NODE_ENV production
ENV APP_PATH /work

WORKDIR $APP_PATH

# Gems installation
COPY Gemfile Gemfile.lock ./

RUN gem install bundler -v $BUNDLER_VERSION

RUN bundle config --global frozen 1 && \
  bundle install && \
  rm -rf /usr/local/bundle/cache/*.gem && \
  find /usr/local/bundle/gems/ -name "*.c" -delete && \
  find /usr/local/bundle/gems/ -name "*.o" -delete

# NPM packages installation
COPY package.json yarn.lock ./

RUN yarn install --frozen-lockfile --non-interactive --production

ADD . $APP_PATH

RUN SECRET_KEY_BASE=`bin/rake secret` rails assets:precompile --trace && \
  yarn cache clean && \
  rm -rf node_modules tmp/cache vendor/assets test

FROM ruby:3.0.2-alpine3.13

RUN mkdir -p /work
WORKDIR /work

ENV RAILS_ENV production
ENV NODE_ENV production
ENV RAILS_SERVE_STATIC_FILES true

# Some native extensions required by gems such as pg or mysql2.
COPY --from=builder /usr/lib /usr/lib

# Timezone data is required at runtime
COPY --from=builder /usr/share/zoneinfo/ /usr/share/zoneinfo/

# Ruby gems
COPY --from=builder /usr/local/bundle /usr/local/bundle

COPY --from=builder /work /work

COPY docker-entrypoint.sh ./


CMD ["bundle", "exec", "sidekiq"]
```

</li>

<li>

#### Dockerignore

In order to avoid unneeded files being copied to your Docker image, you can add a `.dockerignore` file to the root of your project, with the following content: 

```
# See https://help.github.com/articles/ignoring-files for more about ignoring files.
#
# If you find yourself ignoring temporary files generated by your text editor
# or operating system, you probably want to add a global ignore instead:
# git config --global core.excludesfile '~/.gitignore_global'

# Ignore bundler config.
/.bundle

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

# Ignore pidfiles, but keep the directory.
/tmp/pids/*
!/tmp/pids/
!/tmp/pids/.keep

# Ignore uploaded files in development.
/storage/*
!/storage/.keep
/public/assets
.byebug_history

# Ignore master key for decrypting credentials and more.
/config/master.key
/public/packs
/public/packs-test
/node_modules
/yarn-error.log
yarn-debug.log*
.yarn-integrity
```

<Alert type="notice">
  You can customize this file for the needs of your project. Add any file that is not useful for the runtime of your application.
</Alert>

</li>

<li>

#### Docker entrypoint

Finally we will add an entrypoint script that will be called at the start of the application.
We'll use it to run the database setup and migration commands.

You can read more about why this entrypoint is needed [here][guides.tutorial.how-to-run-commands-at-application-startup]. 

<Alert type="notice">
  Soon Qovery will add lifecycle hooks and this won't be needed anymore
</Alert>

Add a `docker-entrypoint.sh` file at the root of your project with the following content: 

```bash
#! /bin/sh

bundle exec rake db:migrate

if [[ $? != 0 ]]; then

echo
echo "== Failed to migrate. Running setup first."
echo

bundle exec rake db:setup
fi

# Execute the given or default command:

exec "$@"
```

Make this script executable: 

```
chmod +x docker-entrypoint.sh
```


</li>

</ol>

</Steps>

## Deploy your application to Qovery

<Steps headingDepth={3}>

<ol>

<li>

#### Create a project

Now that your Rails application is ready to be dockerized, we can create a project on the Qovery console:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/01.png" alt="Qovery console" />
</p>    

</li>

<li>

#### Create an environment

Now we'll create an environment. Let's start with our `staging` environment:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/02.png" alt="Qovery console" />
</p>    

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/03.png" alt="Qovery console" />
</p>    

</li>

<li>

#### Add your Rails app

We'll now add our Rails app to the environment: 

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/04.png" alt="Qovery console" />
</p>    

On the form you'll need to enter the following information:

- The app name: it can be whatever you want. Here `web`.
- Pick your Git privider, then the repository for your application
- The branch you want to deploy for this application. We chose `main`
- The Root application path. In case your application is not at the root of your repository (e.g. you have a monorepo), otherwise it will be `/`.
- For the Build mode, pick `Dockerfile`.
- Enter the path to your Dockerfile.

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/05.png" alt="Qovery console" />
</p>    

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/06.png" alt="Qovery console" />
</p>    

You can then click `Create`. You'll be redirected to your application dashboard.

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/07.png" alt="Qovery console" />
</p>    

<Alert type="notice">
  Your application is not being deployed yet. We'll add the database and do some more configuration before.
</Alert>

</li>

<li>

#### Add a PostgreSQL database

Our application will use a PostgreSQL database. Let's add one to our environment:

Click on `ADD`, then `Database`

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/08.png" alt="Qovery console" />
</p>    

- Give a name to your database.
- For the Type, select `POSTGRESQL`.
- For the Mode, we'll pick `CONTAINER`.
- Chose the Version you need.

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/09.png" alt="Qovery console" />
</p>    

<Alert type="warning">
  Since we are creating a Staging environment, we used the CONTAINER mode. This is not recommended for Production. In Production environment you should go for the MANAGED option.
</Alert>

You can then click `Create`
</li>

<li>

#### Add a Redis database

Since we're using Sidekiq, we'll also need a Redis database as a backend.

If you didn't close the `Database` modal, you can click the `ADD` button, then in the dropbox for `Database 2` click `Create database`.

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/10.png" alt="Qovery console" />
</p>  

Fill the form the same way you did for PostgreSQL:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/11.png" alt="Qovery console" />
</p>  

<Alert type="warning">
  Since we are creating a Staging environment, we used the CONTAINER mode. This is not recommended for Production. In Production environment you should go for the MANAGED option.
</Alert>

Click `Create` and close the Databases modal.

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/12.png" alt="Qovery console" />
</p>  

</li>

<li>

#### Configure your application ENV variables

Go back to your environment view:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/13.png" alt="Qovery console" />
</p>  

Then click on your application:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/14.png" alt="Qovery console" />
</p>  

On your application dashboard, go to `Environment variables`:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/15.png" alt="Qovery console" />
</p>  

Here you can add any environment variable your application needs.

<Alert type="warning">
  Since we are creating a Staging environment, we used the CONTAIWe do not advise you to add secret values here. For sensitive information, like credentials, use the Secret variables, which are encrypted.
</Alert>

We'll now configure a few secrets for our application. Click on the `Secret variables` tab:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/16.png" alt="Qovery console" />
</p>  

First since our Demo application uses the Rails Encrypted Secrets, we'll add the `RAILS_MASTER_KEY` secret
Click on `CREATE SECRET`, then fill the form:

- Variable: enter the variable name, `RAILS_MASTER_KEY`.
- Value: enter the actual value for your `RAILS_MASTER_KEY`.
- Scope: chose `ENVIRONMENT` since the secret will be used by our Sidekiq worker too.

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/17.png" alt="Qovery console" />
</p>  

Now we'll need to add the `DATABASE_URL` and `REDIS_URL`, that Rails will use to connect to PostgreSQL and Redis. Those are secrets as well, since the URLs contain passwords.

But instead of creating new secrets like we did for the `RAILS_MASTER_KEY`, we'll use aliases. Aliases are just a way of giving a different name to an existing ENV variable or secret.
Since Qovery provides us with the secrets corresponding to the two databases we created earlier, we can alias them.

First, create an alias to the `QOVERY_POSTGRESQL_ZXXXXXXXX_DATABASE_URL_INTERNAL`:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/18.png" alt="Qovery console" />
</p>  

In the form, chose `DATABASE_URL` for the alias name and set it at the `ENVIRONMENT` level:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/19.png" alt="Qovery console" />
</p>  

Click `Create` then do the same thing with a `REDIS_URL` alias to the `QOVERY_REDIS_ZXXXXXXXX_DATABASE_URL_INTERNAL`.

You should see your two aliases created:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/20.png" alt="Qovery console" />
</p>  

<Alert type="notice">
  These are the secrets required for our demo application. Yours might need more. Add all the variables you need before going to the next step.
</Alert>

</li>

<li>

#### Deploy the environment

Go back to the `staging` environment view and deploy it:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/21.png" alt="Qovery console" />
</p>  

You should see it switch to the `DEPLOYING` status. Wait until the status turns to `RUNNING`. 

<Alert type="notice">
  The first deployment could take a while.
</Alert>

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/22.png" alt="Qovery console" />
</p>  

Once your environment is `RUNNING`, open the `web` application to see if it works. It will open a new tab showing your application.

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/23.png" alt="Qovery console" />
</p>  

</li>

<li>

#### Add the Sidekiq worker

The last step is to add your Sidekiq Worker. We'll follow the same steps as in the `Add your Rails app` section with a few differences:

Add a new application:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/24.png" alt="Qovery console" />
</p>  

The settigs are the same as for the Rails application, except:

- We use the `Dockerfile.sidekiq` Dockerfile this time
- We don't declare a port since our worker is not a web service but communicates with our application through Redis.

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/25.png" alt="Qovery console" />
</p>  

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/26.png" alt="Qovery console" />
</p>  

Click `Create`.

If we check the ENV variables and secrets, we notice that it directly inherited the ones we set at the `Environment` level. So we don't need to do the configuration again.

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/27.png" alt="Qovery console" />
</p>  

You can now deploy your `worker` application:

<p align="center">
  <img src="/img/deploy-rails-with-postgresql-and-sidekiq/28.png" alt="Qovery console" />
</p>  

Wait for it to switch to the `RUNNING` status.

</li>

</ol>

</Steps>

## Conclusion

You now have a Rails application with PostgreSQL and Sidekiq running on Qovery. 

<Alert type="warning">
  Depending on the gems you are using, their versions or your application configuration, you might need to tweak the Dockerfiles provided. 
  <br />
  This example is meant to be a starting point for your own configuration, not a one-size-fits-all configuration.
</Alert>


[guides.tutorial.how-to-run-commands-at-application-startup]: /guides/tutorial/how-to-run-commands-at-application-startup/
